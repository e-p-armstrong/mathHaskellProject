# A short thing I did for my math class

A long time ago, in a Calc 12 class far, far away, out teacher asked us the "McNugget" problem. Namely, what is the smallest number of McNuggets you cannot buy, given that you can buy 6-packs, 9-packs, and 20-packs. As I had been studying Haskell around that time, I decided to try and use my coding skill to figure it out.

Enter this project. The first function you see is broken so ignore it. The next two (which do the same thing, the second one just more cleanly) test if a number can be made from the given numbers by subtracting them according to a set of rules and seeing if there is a remainder at the end.  Finally, at the end, there's a pair of IO functions (one for the OG testing function, the other for the "lightweight" version) which checks numbers until it's control+C'd, returning a tuple with that number and whether it can be made with 6's, 9's, and 20's (represented with a True/False). It slows down massively as time goes on because I used fancy inefficient recursion and self-calling in the checking functions, but once it reaches the number 100 + the last invalid number, and that is shown to be valid, then you can conclude that every number after that will be valid. Because you can just add 20's until you get to any number you want.

Please note: don't scream at me for writing what might be a solid contender for the most inefficient, slow-executing code in existence. First, this is Haskell. Second, I was very young, and this was literally the first time I had used code for something practical outside of a book.